import { CodeBlock } from "@/components/shared/Codeblock";
import Navbar from "@/components/shared/Navbar";
import Playground from "@/app/docs/useCountDown/Playground";
import Table from "@/app/docs/useCountDown/Table";

<Navbar />

# **useCountDown**

### Manage precise, drift-free countdown timers with absolute-time synchronization and stable playback controls.

#### **Installation**

<CodeBlock
  code={`npm install @vibehooks/react/useCountDown`}
  language="bash"
/>

#### **Description**

The useCountDown is a high-precision, unopinionated React hook designed to manage countdown timers based on absolute timestamps. It recalculates time by comparing the current system clock against a target end time, ensuring inmunity to execution delays or background tab throttling.

The hook provides granular control over the timer's lifecycle, allowing developers to pause, resume, and reset the countdown while maintaining sub-second accuracy and providing predictable lifecycle callbacks.
Unlike traditional counters that rely solely on **setInterval** increments (which are notorious for drifting over time), **useCountDown** uses a **Reference Timestamp** approach. When the timer starts, it calculates the delta between the target **endTime** and **Date.now()**.

#### **Parameters**

<Table.Parameters />

#### **Return values**

<Table.ReturnValues />

#### **Demo**

<Playground />

#### **Source code**

```typescript
'use client';

import React, { useState } from 'react';
import { useCountDown } from '@vibehooks/react/useCountDown';

const CountdownPro: React.FC = () => {
  const [endTime] = useState(() => Date.now() + 20_000);

  const {
    count,
    isPaused,
    controls: { pause, resume, reset },
    status
  } = useCountDown({
    endTime: endTime,
    options: {
      interval: 100,
      onTick: (remaining) => {
        if (remaining < 10000) console.log("Final stretch!");
      },
      onComplete: () => {
        console.log("Countdown finished!");
      }
    }
  });

  const formatTime = (ms: number) => (ms / 1000).toFixed(1);

  return (
      <div className="flex flex-col items-center gap-4 w-full p-4 border border-white/20 rounded-lg shadow-sm">
        <div className='flex flex-col items-center'>
          <h2 className="text-lg text-white/60 font-medium font-sora">
            Time Remaining
          </h2>
          <h3 className="text-2xl font-bold font-reddit-sans">
            {formatTime(count)}s
          </h3>
        </div>

        <div className="flex gap-2">
          <button
            onClick={isPaused ? resume : pause}
            className="px-4 py-2 bg-orange-400 hover:bg-orange-500 transition-colors duration-300 ease-in-out text-white rounded-md cursor-pointer font-reddit-sans"
          >
            {isPaused ? 'Resume' : 'Pause'}
          </button>

          <button
            onClick={() => reset(count + 10_000)}
            className="px-4 py-2 bg-purple-400 hover:bg-purple-500 transition-colors duration-500 ease-in-out rounded-md cursor-pointer font-reddit-sans"
          >
            Add 10s +
          </button>

          <button
            onClick={() => reset()}
            className="px-4 py-2 bg-red-400 hover:bg-red-500 transition-colors duration-500 ease-in-out rounded-md cursor-pointer font-reddit-sans"
          >
            Reset
          </button>
        </div>

        <p className="text-sm text-white/60 font-reddit-sans">
          Status: {status.charAt(0).toUpperCase() + status.slice(1)}
        </p>
      </div>
  );
};

export default CountdownPro;
```
